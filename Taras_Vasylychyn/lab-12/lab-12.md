## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій



### Звіт про виконання лабораторної роботи №11
# "Pattern: Strategy"



| Виконав: студент групи ІТ-41 Василишин Тарас |
|----------------------------------------------|
| Перевірив: Татомир Андрій                    |


**Мета: навчитися використовувати патерн "Стратегія" на практиці.**


Хід роботи

Патерн Стратегія пропонує визначити сімейство схожих алгоритмів, які часто змінюються або розширюються, й винести їх до власних класів, які називають стратегіями.

Замість того, щоб початковий клас сам виконував той чи інший алгоритм, він відіграватиме роль контексту, посилаючись на одну зі стратегій та делегуючи їй виконання роботи. Щоб змінити алгоритм, вам буде достатньо підставити в контекст інший об’єкт-стратегію.

Важливо, щоб всі стратегії мали єдиний інтерфейс. Використовуючи цей інтерфейс, контекст буде незалежним від конкретних класів стратегій. З іншого боку, ви зможете змінювати та додавати нові види алгоритмів, не чіпаючи код контексту.

SortingStrategy - це абстрактний базовий клас, що визначає інтерфейс для різних стратегій сортування. У нього є один метод sort, який очікує data - набір даних, які потрібно відсортувати. В даному випадку, pass вказує на те, що цей метод має бути реалізований в похідних класах.
```
class SortingStrategy:
    def sort(self, data):
        pass
```

BubbleSort - це конкретна стратегія сортування, яка успадковує функціональність від SortingStrategy. Вона реалізує метод sort, де сортування бульбашкою виконується для data. 
```
class BubbleSort(SortingStrategy):
    def sort(self, data):
        print("Використовуємо сортування бульбашкою")
        n = len(data)
        for i in range(n - 1):
            for j in range(0, n - i - 1):
                if data[j] > data[j + 1]:
                    data[j], data[j + 1] = data[j + 1], data[j]
        return data
```

InsertionSort - це ще одна конкретна стратегія сортування, також успадкована від SortingStrategy. Вона також реалізує метод sort.
```
class InsertionSort(SortingStrategy):
    def sort(self, data):
        print("Використовуємо сортування вставкою")
        n = len(data)
        for i in range(1, n):
            key = data[i]
            j = i - 1
            while j >= 0 and key < data[j]:
                data[j + 1] = data[j]
                j -= 1
            data[j + 1] = key
        return data
```

Sorter - це клас контексту, який використовує обрану стратегію сортування для сортування даних. У конструкторі він приймає початкову стратегію сортування, і цю стратегію можна змінити в будь-який момент за допомогою методу set_strategy. Метод perform_sort використовує поточну стратегію для сортування переданих даних.
```
class Sorter:
    def __init__(self, strategy):
        self.strategy = strategy

    def set_strategy(self, strategy):
        self.strategy = strategy

    def perform_sort(self, data):
        return self.strategy.sort(data)
```

Виконав завдання: [Практична робота №12](lab-12.py)


#### Висновки.
Стратегія дозволяє варіювати поведінку об’єкта під час виконання програми, підставляючи до нього різні об’єкти-поведінки (наприклад, що відрізняються балансом швидкості та споживання ресурсів).
Стратегія дозволяє відокремити поведінку, що відрізняється, у власну ієрархію класів, а потім звести початкові класи до одного, налаштовуючи його поведінку стратегіями.
Стратегія дозволяє ізолювати код, дані й залежності алгоритмів від інших об’єктів, приховавши ці деталі всередині класів-стратегій.
Стратегія розміщує кожну лапу такого оператора до окремого класу-стратегії. Потім контекст отримує певний об’єкт-стратегію від клієнта й делегує йому роботу. Якщо раптом знадобиться змінити алгоритм, до контексту можна подати іншу стратегію.